/**
 * Copyright (C) 2025 Karlo MijaljeviÄ‡
 * <p>
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * <p>
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * <p>
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
package xyz.mijaljevic.backup_manager;

import java.io.Closeable;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Represents the H2 database used for backup indexing. Only contains
 * operations tied to the {@link BackupFile} entity and nothing else.
 */
final class BackupDatabase implements Closeable {
    /**
     * Database {@link Connection} used to execute statements.
     */
    private final Connection connection;

    /**
     * Constructor for the backup database class.
     *
     * @param name     Name of the database
     * @param username Database username
     * @param password Database password
     * @throws SQLException in case it fails to create a {@link Connection}
     *                      instance.
     */
    private BackupDatabase(String name, String username, String password) throws SQLException {
        this.connection = DriverManager.getConnection(
                Utils.isStringEmpty(name) ? generateJdbcUrl(Defaults.DEFAULT_DATABASE_NAME) : generateJdbcUrl(name),
                Utils.isStringEmpty(username) ? Defaults.DATABASE_USERNAME : username,
                Utils.isStringEmpty(password) ? Defaults.DATABASE_PASSWORD : password
        );

        configureTable();
    }

    /**
     * Closes the database connection. After this the instance owning the
     * connection should be thrashed.
     * <p>
     * {@inheritDoc}
     */
    @Override
    public void close() {
        try {
            this.connection.close();
        } catch (SQLException e) {
            throw new RuntimeException("Failed to close the database connection", e);
        }
    }

    /**
     * Saves the {@link BackupFile} entity into the database.
     *
     * @param backupFile The backup file to save to the database
     * @return Returns the new {@link BackupFile} with the autogenerated ID
     * @throws SQLException in case it fails to save the entity to the database
     */
    public BackupFile save(BackupFile backupFile) throws SQLException {
        PreparedStatement statement = connection.prepareStatement(
                SqlCommands.INSERT.sql,
                Statement.RETURN_GENERATED_KEYS
        );

        prepareBackupFileStatement(backupFile, statement);

        statement.executeUpdate();

        ResultSet generatedKeys = statement.getGeneratedKeys();

        long id = -1;
        if (generatedKeys.next()) {
            id = generatedKeys.getLong(1);
        }

        statement.close();

        return read(id);
    }

    /**
     * Updates the {@link BackupFile} entity in the database.
     *
     * @param backupFile The backup file to update
     * @return Returns true if the entity was updated and false otherwise
     * @throws SQLException in case it fails to update the entity in the
     *                      database
     */
    public boolean update(BackupFile backupFile) throws SQLException {
        PreparedStatement statement = connection.prepareStatement(SqlCommands.UPDATE.sql);

        prepareBackupFileStatement(backupFile, statement);

        statement.setLong(7, backupFile.getId());

        boolean isSuccess = statement.executeUpdate() == 1;

        statement.close();

        return isSuccess;
    }

    /**
     * Reads a {@link BackupFile} with the provided ID. If no such entity is
     * found in the database null is returned.
     *
     * @param id A {@link Long} ID
     * @return {@link BackupFile} with the provided ID or null
     * @throws SQLException in case it failed to read from the database.
     */
    public BackupFile read(Long id) throws SQLException {
        PreparedStatement statement = connection.prepareStatement(SqlCommands.SELECT.sql);

        statement.setLong(1, id);

        ResultSet result = statement.executeQuery();

        if (!result.next()) {
            return null;
        }

        BackupFile backupFile = createBackupFile(result);

        statement.close();

        return backupFile;
    }

    /**
     * Deletes the {@link BackupFile} entity from the database.
     *
     * @param id The backup file ID
     * @return True if the entity was deleted and false otherwise
     * @throws SQLException in case it fails to delete the entity from the
     *                      database
     */
    public boolean delete(Long id) throws SQLException {
        PreparedStatement statement = connection.prepareStatement(SqlCommands.DELETE.sql);

        statement.setLong(1, id);

        boolean isSuccess = statement.executeUpdate() == 1;

        statement.close();

        return isSuccess;
    }

    /**
     * Returns a page of {@link BackupFile} entities in a {@link List}.
     *
     * @param id       Last read {@link BackupFile} ID
     * @param pageSize The size of the page to return
     * @return Returns a page of {@link BackupFile} entities in a {@link List}.
     * @throws SQLException in case it could not page data in the database
     */
    public List<BackupFile> page(Long id, int pageSize) throws SQLException {
        PreparedStatement statement = connection.prepareStatement(SqlCommands.PAGE.sql);

        statement.setLong(1, id);
        statement.setInt(2, pageSize);

        ResultSet resultSet = statement.executeQuery();
        List<BackupFile> backupFiles = new ArrayList<>();

        while (resultSet.next()) {
            BackupFile backupFile = createBackupFile(resultSet);

            backupFiles.add(backupFile);
        }

        statement.close();

        return backupFiles;
    }

    /**
     * Finds a {@link BackupFile} entity by its path.
     *
     * @param path The path of the file
     * @return {@link BackupFile} with the provided path or null
     * @throws SQLException in case an error occurs while reading from the database
     */
    public BackupFile findByPath(String path) throws SQLException {
        PreparedStatement statement = connection.prepareStatement(SqlCommands.FIND_BY_PATH.sql);

        statement.setString(1, path);

        ResultSet resultSet = statement.executeQuery();

        if (!resultSet.next()) {
            return null;
        }

        BackupFile backupFile = createBackupFile(resultSet);

        statement.close();

        return backupFile;
    }

    /**
     * Checks if the {@link BackupFile} entity table exists. If not then it
     * creates it.
     *
     * @throws SQLException in case it fails to check or create the table.
     */
    private void configureTable() throws SQLException {
        PreparedStatement statement = connection.prepareStatement(SqlCommands.CREATE_TABLE.sql);

        statement.executeUpdate();

        statement.close();
    }

    /**
     * Generates the H2 JDBC URL {@link String} from the environment or user
     * variables if they are set and if not uses default ones.
     *
     * @param name User provided name of the database
     * @return H2 JDBC URL {@link String}
     */
    private String generateJdbcUrl(String name) {
        String jdbcUrlPrefix = "jdbc:h2:";
        String dbPahName = System.getenv(Defaults.DATABASE_ENVIRONMENT_NAME);

        if (name != null) {
            // H2 does not recommend pure name when creating with JDBC parameters
            String sanitizedName = name.matches("^[\\w+.\\-_]+$") ? ("./" + name) : name;

            sanitizedName = sanitizedName.replaceAll(" ", "-");

            return jdbcUrlPrefix + sanitizedName;
        } else return jdbcUrlPrefix + Objects.requireNonNullElse(dbPahName, Defaults.DEFAULT_DATABASE_NAME);
    }

    /**
     * Creates a {@link BackupFile} entity from the {@link ResultSet} object.
     *
     * @param resultSet The {@link ResultSet} object
     * @return {@link BackupFile} entity
     * @throws SQLException in case it fails to create the entity
     */
    private static BackupFile createBackupFile(ResultSet resultSet) throws SQLException {
        BackupFile backupFile = new BackupFile();

        backupFile.setId(resultSet.getLong("id"));
        backupFile.setName(resultSet.getString("name"));
        backupFile.setHash(resultSet.getString("hash"));
        backupFile.setPath(resultSet.getString("path"));
        backupFile.setType(resultSet.getString("type"));
        backupFile.setCreated(resultSet.getTimestamp("created").toLocalDateTime());

        if (resultSet.getTimestamp("updated") == null) {
            backupFile.setUpdated(null);
        } else {
            backupFile.setUpdated(resultSet.getTimestamp("updated").toLocalDateTime());
        }

        return backupFile;
    }

    /**
     * Prepares the {@link PreparedStatement} for the {@link BackupFile}
     * entity. Modifies the statement in place.
     *
     * @param backupFile The {@link BackupFile} entity
     * @param statement  The {@link PreparedStatement} object
     * @throws SQLException in case it fails to prepare the statement
     */
    private static void prepareBackupFileStatement(
            BackupFile backupFile,
            PreparedStatement statement
    ) throws SQLException {
        statement.setString(1, backupFile.getName());
        statement.setString(2, backupFile.getHash());
        statement.setString(3, backupFile.getPath());
        statement.setString(4, backupFile.getType());
        statement.setTimestamp(5, Timestamp.valueOf(backupFile.getCreated()));

        if (backupFile.getUpdated() == null) {
            statement.setTimestamp(6, null);
        } else {
            statement.setTimestamp(6, Timestamp.valueOf(backupFile.getUpdated()));
        }
    }

    /**
     * Builder class for the {@link BackupDatabase} class. It is used to
     * create a new {@link BackupDatabase} instance.
     */
    static final class BackupDatabaseBuilder {
        private String name;
        private String username;
        private String password;

        public static BackupDatabaseBuilder builder() {
            return new BackupDatabaseBuilder();
        }

        public BackupDatabaseBuilder setName(String name) {
            this.name = name;
            return this;
        }

        public BackupDatabaseBuilder setUsername(String username) {
            this.username = username;
            return this;
        }

        public BackupDatabaseBuilder setPassword(String password) {
            this.password = password;
            return this;
        }

        public BackupDatabase build() throws SQLException {
            return new BackupDatabase(name, username, password);
        }
    }

    /**
     * SQL commands used in the database. Supported commands are:
     * <ul>
     *     <li>CREATE_TABLE</li>
     *     <li>INSERT</li>
     *     <li>UPDATE</li>
     *     <li>SELECT</li>
     *     <li>DELETE</li>
     *     <li>PAGE</li>
     *     <li>FIND_BY_PATH</li>
     * </ul>
     * The SQL commands are used to create the table, insert data, select data,
     * delete data and page data from the database. Operates only on the
     * {@link BackupFile} entity.
     */
    private enum SqlCommands {
        CREATE_TABLE("""
                     CREATE TABLE IF NOT EXISTS backup_files (
                         id BIGINT AUTO_INCREMENT PRIMARY KEY,
                         name VARCHAR(256) NOT NULL,
                         hash VARCHAR(256) NOT NULL,
                         path VARCHAR(1024) UNIQUE NOT NULL,
                         type VARCHAR(256) NOT NULL,
                         created TIMESTAMP NOT NULL,
                         updated TIMESTAMP
                     );
                     """
        ),
        INSERT("""
               INSERT INTO backup_files
               (name, hash, path, type, created, updated) VALUES
               (?, ?, ?, ?, ?, ?);
               """
        ),
        SELECT("""
               SELECT * FROM backup_files
               WHERE id = ?;
               """
        ),
        DELETE("""
               DELETE FROM backup_files
               WHERE id = ?;
               """
        ),
        UPDATE("""
               UPDATE backup_files
               SET name = ?, hash = ?, path = ?, type = ?, created = ?, updated = ?
               WHERE id = ?;
               """
        ),
        PAGE("""
             SELECT * FROM backup_files
             WHERE id > ?
             ORDER BY id
             LIMIT ?;
             """
        ),
        FIND_BY_PATH("""
                     SELECT * FROM backup_files
                     WHERE path = ?;
                     """
        );

        private final String sql;

        SqlCommands(String sql) {
            this.sql = sql;
        }
    }
}
