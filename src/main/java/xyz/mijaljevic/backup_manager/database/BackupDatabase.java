/**
 * Copyright (C) 2025 Karlo MijaljeviÄ‡
 *
 * <p>
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * </p>
 *
 * <p>
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * </p>
 *
 * <p>
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 * </p>
 */
package xyz.mijaljevic.backup_manager.database;

import xyz.mijaljevic.backup_manager.Defaults;
import xyz.mijaljevic.backup_manager.utilities.Utils;

import java.io.Closeable;
import java.nio.file.FileSystems;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Represents the H2 database used for backup indexing. Contains operations
 * tied to the {@link BackupFile} entity as well as the builder.
 */
public final class BackupDatabase implements Closeable {
    /**
     * Database {@link Connection} used to execute statements.
     */
    private final Connection connection;

    /**
     * Regex used to validate the database name. It checks if the name is a
     * relative or absolute path.
     */
    private final static String DATABASE_NAME_REGEX = "^\\./.+|^/.+|^\\.\\\\.+|^[A-Z]:.+";

    /**
     * Builder class for the {@link BackupDatabase} class.
     */
    public static final class Builder {
        /**
         * Connection property that  specifies that a connection should only be
         * completed if the requested database already exists.
         */
        private static final String IFEXISTS = "IFEXISTS=TRUE";

        /**
         * Character used to device properties in the connection string.
         */
        private static final String PROPERTY_DIVIDER = ";";

        private String name;
        private String username;
        private String password;

        public static Builder builder() {
            return new Builder();
        }

        public Builder setName(String name) {
            this.name = name;
            return this;
        }

        public Builder setUsername(String username) {
            this.username = username;
            return this;
        }

        public Builder setPassword(String password) {
            this.password = password;
            return this;
        }

        /**
         * Appends the IFEXISTS property to the connection string. That way
         * the connection will only be established if the database already
         * exists. If it does not exist an exception will be thrown.
         *
         * @return The current instance of the builder
         */
        public Builder appendIfExists() {
            this.name = this.name + PROPERTY_DIVIDER + IFEXISTS;
            return this;
        }

        public BackupDatabase build() throws SQLException {
            return new BackupDatabase(name, username, password);
        }
    }

    /**
     * Constructor for the backup database class.
     *
     * @param name     Name of the database
     * @param username Database username
     * @param password Database password
     * @throws SQLException in case it fails to create a {@link Connection}
     *                      instance.
     */
    private BackupDatabase(
            String name,
            String username,
            String password
    ) throws SQLException {
        this.connection = DriverManager.getConnection(
                Utils.isStringEmpty(name)
                        ? generateJdbcUrl(Defaults.DATABASE_NAME)
                        : generateJdbcUrl(name),
                Utils.isStringEmpty(username)
                        ? Defaults.DATABASE_USERNAME
                        : username,
                Utils.isStringEmpty(password)
                        ? Defaults.DATABASE_PASSWORD
                        : password
        );

        configureTable();
    }

    /**
     * Closes the database connection. After this the instance owning the
     * connection should be thrashed.
     * <p>
     * {@inheritDoc}
     */
    @Override
    public void close() {
        try {
            this.connection.close();
        } catch (SQLException e) {
            throw new RuntimeException(
                    "Failed to close the database connection",
                    e
            );
        }
    }

    /**
     * Saves the {@link BackupFile} entity into the database.
     *
     * @param backupFile The backup file to save to the database
     * @return Returns the new {@link BackupFile} with the autogenerated ID
     * @throws SQLException in case it fails to save the entity to the database
     */
    public synchronized BackupFile save(
            BackupFile backupFile
    ) throws SQLException {
        PreparedStatement statement = connection.prepareStatement(
                SqlCommands.INSERT.sql,
                Statement.RETURN_GENERATED_KEYS
        );

        prepareBackupFileStatement(backupFile, statement);

        statement.executeUpdate();

        ResultSet generatedKeys = statement.getGeneratedKeys();

        long id = -1;
        if (generatedKeys.next()) {
            id = generatedKeys.getLong(1);
        }

        statement.close();

        return read(id);
    }

    /**
     * Updates the {@link BackupFile} entity in the database.
     *
     * @param backupFile The backup file to update
     * @return Returns true if the entity was updated and false otherwise
     * @throws SQLException in case it fails to update the entity in the
     *                      database
     */
    public synchronized boolean update(
            BackupFile backupFile
    ) throws SQLException {
        PreparedStatement statement = prepare(SqlCommands.UPDATE);

        prepareBackupFileStatement(backupFile, statement);

        statement.setLong(7, backupFile.getId());

        boolean isSuccess = statement.executeUpdate() == 1;

        statement.close();

        return isSuccess;
    }

    /**
     * Reads a {@link BackupFile} with the provided ID. If no such entity is
     * found in the database null is returned.
     *
     * @param id A {@link Long} ID
     * @return {@link BackupFile} with the provided ID or null
     * @throws SQLException in case it failed to read from the database.
     */
    public BackupFile read(Long id) throws SQLException {
        PreparedStatement statement = prepare(SqlCommands.SELECT);

        statement.setLong(1, id);

        ResultSet result = statement.executeQuery();

        if (!result.next()) {
            return null;
        }

        BackupFile backupFile = createBackupFile(result);

        statement.close();

        return backupFile;
    }

    /**
     * Deletes the {@link BackupFile} entity from the database.
     *
     * @param id The backup file ID
     * @return True if the entity was deleted and false otherwise
     * @throws SQLException in case it fails to delete the entity from the
     *                      database
     */
    public synchronized boolean delete(Long id) throws SQLException {
        PreparedStatement statement = prepare(SqlCommands.DELETE);

        statement.setLong(1, id);

        boolean isSuccess = statement.executeUpdate() == 1;

        statement.close();

        return isSuccess;
    }

    /**
     * Returns a page of {@link BackupFile} entities in a {@link List}.
     *
     * @param id       Last read {@link BackupFile} ID
     * @param pageSize The size of the page to return
     * @return Returns a page of {@link BackupFile} entities in a {@link List}.
     * @throws SQLException in case it could not page data in the database
     */
    public List<BackupFile> page(Long id, int pageSize) throws SQLException {
        PreparedStatement statement = prepare(SqlCommands.PAGE);

        statement.setLong(1, id);
        statement.setInt(2, pageSize);

        ResultSet resultSet = statement.executeQuery();
        List<BackupFile> backupFiles = new ArrayList<>();

        while (resultSet.next()) {
            BackupFile backupFile = createBackupFile(resultSet);

            backupFiles.add(backupFile);
        }

        statement.close();

        return backupFiles;
    }

    /**
     * Returns the number of {@link BackupFile} entities in the database.
     *
     * @return The number of {@link BackupFile} entities in the database
     * @throws SQLException in case it fails to count the entities in the
     *                      database
     */
    public long count() throws SQLException {
        PreparedStatement statement = prepare(SqlCommands.COUNT);

        ResultSet resultSet = statement.executeQuery();

        if (!resultSet.next()) {
            return 0;
        }

        long count = resultSet.getLong(1);

        statement.close();

        return count;
    }

    /**
     * Finds a {@link BackupFile} entity by its path.
     *
     * @param path The path of the file
     * @return {@link BackupFile} with the provided path or null
     * @throws SQLException in case an error occurs while reading from the
     *                      database
     */
    public BackupFile findByPath(String path) throws SQLException {
        PreparedStatement statement = prepare(SqlCommands.FIND_BY_PATH);

        statement.setString(1, path);

        ResultSet resultSet = statement.executeQuery();

        if (!resultSet.next()) {
            return null;
        }

        BackupFile backupFile = createBackupFile(resultSet);

        statement.close();

        return backupFile;
    }

    /**
     * Lists all IDs of the {@link BackupFile} entities in the database.
     *
     * @return A {@link List} of all {@link BackupFile} IDs
     * @throws SQLException in case it fails to read from the database
     */
    public List<Long> listAllIds() throws SQLException {
        PreparedStatement statement = prepare(SqlCommands.LIST_ALL_IDS);

        ResultSet resultSet = statement.executeQuery();
        List<Long> ids = new ArrayList<>();

        while (resultSet.next()) {
            ids.add(resultSet.getLong("id"));
        }

        statement.close();

        return ids;
    }

    /**
     * Checks if the {@link BackupFile} entity table exists. If it does not
     * exist it creates it.
     *
     * @throws SQLException in case it fails to check or create the table.
     */
    private synchronized void configureTable() throws SQLException {
        PreparedStatement statement = prepare(SqlCommands.CREATE_TABLE);

        statement.executeUpdate();

        statement.close();
    }

    /**
     * Generates the H2 JDBC URL {@link String} from the user variable.
     *
     * @param name User provided name of the database
     * @return H2 JDBC URL {@link String}
     */
    private String generateJdbcUrl(String name) {
        final String jdbcUrlPrefix = "jdbc:h2:";

        if (name != null) {
            // H2 does not recommend pure name when creating with JDBC parameters
            String sanitizedName = name.matches(DATABASE_NAME_REGEX)
                    ? ("." + FileSystems.getDefault().getSeparator() + name)
                    : name;

            sanitizedName = sanitizedName.replaceAll(" ", "-");

            return jdbcUrlPrefix + sanitizedName;
        } else throw new NullPointerException("Database name cannot be null!");
    }

    /**
     * Creates a {@link BackupFile} entity from the {@link ResultSet} object.
     *
     * @param resultSet The {@link ResultSet} object
     * @return {@link BackupFile} entity
     * @throws SQLException in case it fails to create the entity
     */
    private static BackupFile createBackupFile(ResultSet resultSet) throws SQLException {
        BackupFile backupFile = new BackupFile();

        backupFile.setId(resultSet.getLong("id"));
        backupFile.setName(resultSet.getString("name"));
        backupFile.setHash(resultSet.getString("hash"));
        backupFile.setPath(resultSet.getString("path"));
        backupFile.setType(resultSet.getString("type"));
        backupFile.setCreated(resultSet.getTimestamp("created").toLocalDateTime());

        if (resultSet.getTimestamp("updated") == null) {
            backupFile.setUpdated(null);
        } else {
            backupFile.setUpdated(resultSet.getTimestamp("updated").toLocalDateTime());
        }

        return backupFile;
    }

    /**
     * Prepares the {@link PreparedStatement} for the {@link BackupFile}
     * entity. Modifies the statement in place.
     *
     * @param backupFile The {@link BackupFile} entity
     * @param statement  The {@link PreparedStatement} object
     * @throws SQLException in case it fails to prepare the statement
     */
    private static void prepareBackupFileStatement(
            BackupFile backupFile,
            PreparedStatement statement
    ) throws SQLException {
        statement.setString(1, backupFile.getName());
        statement.setString(2, backupFile.getHash());
        statement.setString(3, backupFile.getPath());
        statement.setString(4, backupFile.getType());
        statement.setTimestamp(5, Timestamp.valueOf(backupFile.getCreated()));

        if (backupFile.getUpdated() == null) {
            statement.setTimestamp(6, null);
        } else {
            statement.setTimestamp(6, Timestamp.valueOf(backupFile.getUpdated()));
        }
    }

    /**
     * Prepares a {@link PreparedStatement} from the provided
     * {@link SqlCommands} enum.
     *
     * @param command The {@link SqlCommands} enum
     * @return A {@link PreparedStatement} object
     * @throws SQLException in case it fails to prepare the statement
     */
    private PreparedStatement prepare(
            SqlCommands command
    ) throws SQLException {
        return connection.prepareStatement(command.sql);
    }
}
